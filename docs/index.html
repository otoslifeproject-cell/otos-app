<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OTOS • Cockpit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="./styles.css" />
</head>

<body>
  <div class="cockpit" id="cockpit">
    <!-- PARENT -->
    <section class="zone" id="zone-parent" data-zone="parent" tabindex="0" aria-label="Parent zone">
      <button class="expand" type="button" data-action="reset" aria-label="Reset focus & layout">⤢</button>
      <div class="grab" aria-hidden="true" title="Drag">⋮⋮</div>

      <header class="zone-head">
        <h2>PARENT</h2>
        <p>Authority · Read · Lock · Authorise</p>
      </header>

      <div class="zone-body">
        <!-- intentionally blank for now -->
      </div>
    </section>

    <!-- CORE -->
    <section class="zone" id="zone-core" data-zone="core" tabindex="0" aria-label="Core zone">
      <button class="expand" type="button" data-action="reset" aria-label="Reset focus & layout">⤢</button>
      <div class="grab" aria-hidden="true" title="Drag">⋮⋮</div>

      <header class="zone-head">
        <h2>CORE</h2>
        <p>One action. Calm surface. Primary focus zone.</p>
      </header>

      <div class="zone-body">
        <!-- intentionally blank for now -->
      </div>
    </section>

    <!-- ANDY -->
    <section class="zone" id="zone-andy" data-zone="andy" tabindex="0" aria-label="Andy zone">
      <button class="expand" type="button" data-action="reset" aria-label="Reset focus & layout">⤢</button>
      <div class="grab" aria-hidden="true" title="Drag">⋮⋮</div>

      <header class="zone-head">
        <h2>ANDY</h2>
        <p>Execution agent (token-gated)</p>
      </header>

      <div class="zone-body">
        <div class="panel">
          <div class="drop" id="andyDrop" aria-label="Drop files here">
            Drop file or paste text (visual only)
          </div>

          <input class="input" id="andyCommand" placeholder="Command: A / G / R / C / T" />

          <div class="button-row">
            <button class="btn" type="button" id="btnIngest">Ingest</button>
            <button class="btn secondary" type="button" id="btnDry">Dry run</button>
          </div>

          <div class="status-row">
            <span class="dot idle" id="runDot"></span>
            <span id="runState">Idle</span>
          </div>

          <div class="stats">
            <span>Processed: <strong id="processed">0</strong></span>
            <span>Queue: <strong id="queue">0</strong></span>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
(() => {
  const cockpit = document.getElementById('cockpit');
  const zones = Array.from(document.querySelectorAll('.zone'));

  // -----------------------------
  // Focus / Blur (2-stage)
  // -----------------------------
  function clearFocus() {
    zones.forEach(z => {
      z.classList.remove('focused');
      z.classList.remove('blurred');
    });
    document.body.classList.remove('has-focus');
  }

  function setFocus(target) {
    zones.forEach(z => {
      const isTarget = z === target;
      z.classList.toggle('focused', isTarget);
      z.classList.toggle('blurred', !isTarget);
    });
    document.body.classList.add('has-focus');
  }

  zones.forEach(zone => {
    zone.addEventListener('click', (e) => {
      // Reset button
      if (e.target && e.target.matches('[data-action="reset"]')) {
        e.stopPropagation();
        clearFocus();
        resetLayout(); // also resets positions
        return;
      }

      // If clicking inside inputs/buttons, don't change focus
      if (e.target.closest('input, button, textarea, select')) return;

      // Click focuses zone
      setFocus(zone);
    });

    // Keyboard focus support (Enter/Space)
    zone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        setFocus(zone);
      }
      if (e.key === 'Escape') {
        clearFocus();
      }
    });
  });

  // Background click clears focus
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.zone')) clearFocus();
  });

  // -----------------------------
  // Drag (click & hold anywhere on tile, except controls)
  // + Soft snap on drop
  // -----------------------------
  const GRID = 24; // snap size
  const dragState = {
    active: null,
    startX: 0, startY: 0,
    baseLeft: 0, baseTop: 0,
    moved: false
  };

  // Initial "default grid" positions are handled by CSS grid.
  // Once user drags a tile, we convert it to absolute positioning.
  function ensureAbsolute(zone) {
    if (zone.dataset.abs === '1') return;

    // compute current on-screen position relative to cockpit
    const cRect = cockpit.getBoundingClientRect();
    const zRect = zone.getBoundingClientRect();

    const left = zRect.left - cRect.left;
    const top  = zRect.top  - cRect.top;

    zone.style.left = `${left}px`;
    zone.style.top  = `${top}px`;
    zone.style.width = `${zRect.width}px`; // keep size stable

    zone.classList.add('is-abs');
    zone.dataset.abs = '1';
  }

  function snap(n) {
    return Math.round(n / GRID) * GRID;
  }

  function onPointerDown(e) {
    const zone = e.target.closest('.zone');
    if (!zone) return;

    // don't start drag from controls
    if (e.target.closest('input, button, textarea, select')) return;

    // prevent accidental drag on simple click; require hold + move threshold
    ensureAbsolute(zone);

    const cRect = cockpit.getBoundingClientRect();
    const left = parseFloat(zone.style.left || 0);
    const top  = parseFloat(zone.style.top  || 0);

    dragState.active = zone;
    dragState.startX = e.clientX;
    dragState.startY = e.clientY;
    dragState.baseLeft = left;
    dragState.baseTop = top;
    dragState.moved = false;

    zone.setPointerCapture(e.pointerId);
    zone.classList.add('dragging');
  }

  function onPointerMove(e) {
    if (!dragState.active) return;

    const dx = e.clientX - dragState.startX;
    const dy = e.clientY - dragState.startY;

    // movement threshold
    if (!dragState.moved && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) {
      dragState.moved = true;
      // while dragging, keep focus if already focused; otherwise don't force focus
    }

    const zone = dragState.active;
    const cRect = cockpit.getBoundingClientRect();
    const zRect = zone.getBoundingClientRect();

    // compute raw new position
    let newLeft = dragState.baseLeft + dx;
    let newTop  = dragState.baseTop + dy;

    // clamp inside cockpit
    const maxLeft = cRect.width - zRect.width;
    const maxTop  = cRect.height - zRect.height;

    newLeft = Math.max(0, Math.min(maxLeft, newLeft));
    newTop  = Math.max(0, Math.min(maxTop, newTop));

    zone.style.left = `${newLeft}px`;
    zone.style.top  = `${newTop}px`;
  }

  function onPointerUp(e) {
    if (!dragState.active) return;

    const zone = dragState.active;

    // snap to grid on drop
    const left = parseFloat(zone.style.left || 0);
    const top  = parseFloat(zone.style.top  || 0);

    zone.style.left = `${snap(left)}px`;
    zone.style.top  = `${snap(top)}px`;

    zone.classList.remove('dragging');
    dragState.active = null;
  }

  cockpit.addEventListener('pointerdown', onPointerDown);
  cockpit.addEventListener('pointermove', onPointerMove);
  cockpit.addEventListener('pointerup', onPointerUp);
  cockpit.addEventListener('pointercancel', onPointerUp);

  // -----------------------------
  // Reset Layout (back to grid)
  // -----------------------------
  function resetLayout() {
    zones.forEach(z => {
      z.classList.remove('is-abs', 'dragging');
      z.dataset.abs = '0';
      z.style.left = '';
      z.style.top = '';
      z.style.width = '';
    });
  }

  // -----------------------------
  // ANDY demo status (visual only)
  // -----------------------------
  const runDot = document.getElementById('runDot');
  const runState = document.getElementById('runState');
  const processed = document.getElementById('processed');
  const queue = document.getElementById('queue');

  function setRunState(state) {
    runState.textContent = state;
    runDot.classList.remove('idle', 'complete');
    if (state === 'Idle') runDot.classList.add('idle');
    else runDot.classList.add('complete');
  }

  document.getElementById('btnIngest').addEventListener('click', () => {
    setRunState('Complete');
    processed.textContent = String(Number(processed.textContent || '0') + 1);
  });

  document.getElementById('btnDry').addEventListener('click', () => {
    setRunState('Complete');
    queue.textContent = '0';
  });

  // Drop area visual feedback
  const andyDrop = document.getElementById('andyDrop');
  ['dragenter','dragover'].forEach(evt => {
    andyDrop.addEventListener(evt, (e) => {
      e.preventDefault();
      andyDrop.classList.add('hot');
    });
  });
  ['dragleave','drop'].forEach(evt => {
    andyDrop.addEventListener(evt, (e) => {
      e.preventDefault();
      andyDrop.classList.remove('hot');
    });
  });

})();
</script>
</body>
</html>
