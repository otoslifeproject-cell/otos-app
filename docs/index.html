<!-- FILE: docs/index.html
     LAYER: 3.1 (HOTFIX)
     PURPOSE:
       1) FIX CSS LEAK (style text rendering on-screen)
       2) SECURE PARENT (never blurred, never draggable, never moved by focus)
       3) KEEP LAYER-3 BEHAVIOUR (drag/snap/focus/collapse->go-home for non-parent)
     NOTE:
       - No persistence
       - No agents
       - No RAG
       - No background processes
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cockpit • Environment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg0:#eef5ff;
      --bg1:#eaf2fb;
      --bg2:#f6f9ff;

      --ink:#0f172a;
      --muted:#475569;

      --accent:#f97316;
      --accent2:#ff8a3d;

      --shadow-1: rgba(15,23,42,.10);
      --shadow-2: rgba(15,23,42,.16);
      --shadow-3: rgba(15,23,42,.22);

      --r: 22px;
      --ease: cubic-bezier(.22,.61,.36,1);
      --dur: 180ms;
      --dur2: 260ms;

      --grid: 24px;
      --blur: 10px;
      --pad: 24px;
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
      color:var(--ink);
      background: radial-gradient(1200px 800px at 50% -10%, var(--bg2) 0%, var(--bg0) 40%, var(--bg1) 100%);
      overflow:hidden; /* destination mode */
    }

    /* Outer “Deans World” frame */
    .frame{
      position:fixed;
      inset:12px;
      border-radius:28px;
      background:
        radial-gradient(900px 700px at 40% 10%, rgba(255,255,255,.55), rgba(255,255,255,.0) 55%),
        linear-gradient(180deg, rgba(255,255,255,.25), rgba(255,255,255,.06));
      box-shadow:
        0 18px 70px rgba(15,23,42,.14),
        inset 1px 1px 0 rgba(255,255,255,.55);
      overflow:hidden;
    }

    .watermark{
      position:absolute;
      inset:-40px;
      pointer-events:none;
      opacity:.14;
      background: repeating-linear-gradient(135deg, rgba(15,23,42,.06) 0 2px, transparent 2px 22px);
      mix-blend-mode:multiply;
    }
    .watermark::after{
      content:"COCKPIT";
      position:absolute;
      left:6%;
      bottom:6%;
      font-weight:800;
      letter-spacing:.12em;
      font-size: clamp(72px, 13vw, 200px);
      color: rgba(15,23,42,.10);
      transform: skewX(-6deg);
      user-select:none;
    }

    /* Click-to-clear focus veil (only dims; DOES NOT “go home”) */
    .veil{
      position:absolute;
      inset:0;
      background: rgba(238,245,255,.38);
      backdrop-filter: blur(3px);
      opacity:0;
      pointer-events:none;
      transition: opacity var(--dur2) var(--ease);
      z-index:2;
    }
    .veil.on{
      opacity:1;
      pointer-events:auto;
    }

    .stage{
      position:absolute;
      inset:0;
      z-index:3;
    }

    /* Zone surface */
    .zone{
      position:absolute;
      border-radius: var(--r);
      padding:18px 20px;
      min-width: 260px;

      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.78));
      box-shadow:
        inset 1px 1px 0 rgba(255,255,255,.85),
        inset 0 0 0 1px rgba(255,255,255,.40);

      transform: translate3d(0,0,0);
      will-change: transform, filter, left, top;

      transition:
        transform var(--dur) var(--ease),
        filter var(--dur) var(--ease);
      z-index:3;
    }

    .zone::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: inherit;
      pointer-events:none;
      box-shadow:
        10px 18px 40px var(--shadow-1),
        16px 26px 60px rgba(15,23,42,.08);
      opacity:.95;
      transition: box-shadow var(--dur2) var(--ease), opacity var(--dur2) var(--ease);
    }

    .zone:hover{
      transform: translate3d(0,-2px,0);
    }
    .zone:hover::after{
      box-shadow:
        12px 22px 52px var(--shadow-2),
        18px 34px 78px rgba(15,23,42,.10);
      opacity:1;
    }

    .zone.focused{
      transform: translate3d(0,-6px,0);
      z-index:50;
    }
    .zone.focused::after{
      box-shadow:
        14px 28px 70px var(--shadow-3),
        22px 44px 110px rgba(15,23,42,.12);
      opacity:1;
    }

    .zone.blurred{
      filter: blur(var(--blur)) brightness(.98) saturate(.98);
      pointer-events:none;
    }

    .zone.dragging{
      transition:none !important;
      cursor:grabbing;
      z-index:80;
    }
    .zone.dragging::after{
      transition:none !important;
      opacity:1;
      box-shadow:
        14px 28px 70px var(--shadow-3),
        22px 44px 110px rgba(15,23,42,.12);
    }

    /* Collapsed (self tidy, but anchored) */
    .zone.collapsed{
      padding:14px 16px;
      height:auto !important;
    }
    .zone.collapsed .content,
    .zone.collapsed .subtitle{
      display:none;
    }

    /* Parent lock: never blurred, never draggable, always above dimming */
    .zone.parent-locked{
      z-index:70;
    }
    .zone.parent-locked.blurred{
      filter:none !important;
      pointer-events:auto !important;
    }
    .zone.parent-locked .header{
      cursor:default;
    }

    .header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      user-select:none;
      cursor:grab;
    }

    .titleRow{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .title{
      margin:0;
      font-size:1.0rem;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:4px 0 0;
      color:var(--muted);
      font-size:.98rem;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 10px;
      border-radius:999px;
      font-size:.78rem;
      font-weight:750;
      letter-spacing:.04em;
      color:#fff;
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      box-shadow: 0 8px 18px rgba(15,23,42,.16);
      transform: translateY(-1px);
      user-select:none;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      padding-top:2px;
    }
    .iconBtn{
      width:34px;
      height:34px;
      border-radius:999px;
      display:grid;
      place-items:center;
      cursor:pointer;
      border:none;
      background: rgba(255,255,255,.92);
      box-shadow:
        6px 10px 22px rgba(15,23,42,.10),
        inset 1px 1px 0 rgba(255,255,255,.85);
      transition: transform var(--dur) var(--ease), box-shadow var(--dur) var(--ease);
      font-size:15px;
      line-height:1;
    }
    .iconBtn:hover{
      transform: translateY(-1px);
      box-shadow:
        8px 14px 28px rgba(15,23,42,.14),
        inset 1px 1px 0 rgba(255,255,255,.88);
    }

    .content{ margin-top:14px; }

    .panel{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .input{
      padding:14px 16px;
      border-radius:14px;
      background: linear-gradient(180deg, rgba(238,245,255,.85), rgba(234,242,251,.85));
      box-shadow:
        inset 5px 5px 10px rgba(15,23,42,.10),
        inset -5px -5px 10px rgba(255,255,255,.85);
      font-size:1rem;
      border:none;
      outline:none;
      color:var(--ink);
    }
    .input::placeholder{ color: rgba(71,85,105,.85); }

    .button-row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .btn{
      flex:1;
      padding:14px 0;
      border-radius:16px;
      font-weight:650;
      font-size:1rem;
      cursor:pointer;
      border:none;
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      color:#fff;
      box-shadow:
        0 10px 22px rgba(15,23,42,.16),
        inset 0 1px 0 rgba(255,255,255,.55);
      transition: transform 140ms var(--ease), box-shadow 160ms var(--ease);
    }
    .btn:hover{
      transform: translateY(-2px);
      box-shadow:
        0 14px 30px rgba(15,23,42,.18),
        inset 0 1px 0 rgba(255,255,255,.55);
    }
    .btn:active{
      transform: translateY(1px);
      box-shadow:
        0 8px 18px rgba(15,23,42,.20),
        inset 0 2px 8px rgba(15,23,42,.20);
    }
    .btn.secondary{
      background: rgba(255,255,255,.92);
      color:var(--ink);
      box-shadow:
        0 10px 22px rgba(15,23,42,.12),
        inset 1px 1px 0 rgba(255,255,255,.85);
    }

    .statusBox{
      width:100%;
      border-radius:16px;
      background: linear-gradient(180deg, rgba(238,245,255,.70), rgba(238,245,255,.55));
      box-shadow:
        inset 5px 5px 10px rgba(15,23,42,.08),
        inset -5px -5px 10px rgba(255,255,255,.85);
      padding:14px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 1.45;
      color: rgba(15,23,42,.88);
      white-space: pre;
      overflow:auto;
      max-height: 220px;
    }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .frame{ position:relative; inset:auto; margin:12px; height:auto; min-height: calc(100vh - 24px); }
      .veil{ position:fixed; }
      .stage{ position:relative; height: 900px; }
    }
  </style>
</head>

<body>
  <div class="frame" id="frame">
    <div class="watermark" aria-hidden="true"></div>
    <div class="veil" id="veil" title="Click to clear focus"></div>
    <div class="stage" id="stage" aria-label="Cockpit stage"></div>
  </div>

  <script>
    // =========================
    // LAYER 3.1: UI BEHAVIOUR ONLY
    // FIXES:
    //  - CSS leak hard fix (clean DOM, no injected CSS text)
    //  - Parent is LOCKED: never blurred, never draggable, never moved by focus
    //  - Click background/veil => clear focus (NO go-home)
    // =========================

    const stage = document.getElementById('stage');
    const veil  = document.getElementById('veil');

    const GRID = 24;
    const PAD  = 24;

    const ZONES = [
      { id:'parent', title:'PARENT', subtitle:'Authority · Contract · Lock', w: 380, h: 170, home:{ x: 36,  y: 28 },  locked:true },
      { id:'core',   title:'CORE',   subtitle:'Primary action surface',     w: 420, h: 170, home:{ x: 460, y: 28 },  locked:false },
      { id:'andy',   title:'ANDY',   subtitle:'Execution agent (OFF)',      w: 420, h: 250, home:{ x: 910, y: 28 },  locked:false },
      { id:'status', title:'STATUS', subtitle:'Install · Constraints · Visibility', w: 820, h: 320, home:{ x: 170, y: 220 }, locked:false },
    ];

    function snap(n){ return Math.round(n / GRID) * GRID; }

    function clampToStage(x, y, el){
      const r = stage.getBoundingClientRect();
      const w = el.offsetWidth;
      const h = el.offsetHeight;

      const minX = PAD;
      const minY = PAD;
      const maxX = (r.width  - w - PAD);
      const maxY = (r.height - h - PAD);

      return {
        x: Math.max(minX, Math.min(maxX, x)),
        y: Math.max(minY, Math.min(maxY, y))
      };
    }

    function buildZone(z){
      const el = document.createElement('section');
      el.className = 'zone';
      el.id = z.id;
      el.dataset.zone = z.id;
      el.dataset.locked = z.locked ? '1' : '0';

      el.dataset.homeX = String(z.home.x);
      el.dataset.homeY = String(z.home.y);

      el.style.width  = z.w + 'px';
      el.style.height = z.h + 'px';
      el.style.left   = z.home.x + 'px';
      el.style.top    = z.home.y + 'px';

      if (z.locked) el.classList.add('parent-locked');

      const header = document.createElement('div');
      header.className = 'header';

      const left = document.createElement('div');

      const titleRow = document.createElement('div');
      titleRow.className = 'titleRow';

      const h2 = document.createElement('h2');
      h2.className = 'title';
      h2.textContent = z.title;

      titleRow.appendChild(h2);

      if (z.locked){
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = 'LOCKED';
        titleRow.appendChild(badge);
      }

      const p = document.createElement('p');
      p.className = 'subtitle';
      p.textContent = z.subtitle;

      left.appendChild(titleRow);
      left.appendChild(p);

      const controls = document.createElement('div');
      controls.className = 'controls';

      // Collapse (returns home + collapse) — disabled for Parent
      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'iconBtn';
      collapseBtn.type = 'button';
      collapseBtn.title = z.locked ? 'Parent is locked' : 'Collapse (returns home)';
      collapseBtn.textContent = '–';
      if (z.locked){
        collapseBtn.disabled = true;
        collapseBtn.style.opacity = '.45';
        collapseBtn.style.cursor = 'not-allowed';
      }

      // Expand (uncollapse) — allowed for all
      const expandBtn = document.createElement('button');
      expandBtn.className = 'iconBtn';
      expandBtn.type = 'button';
      expandBtn.title = 'Expand';
      expandBtn.textContent = '⤢';

      controls.appendChild(collapseBtn);
      controls.appendChild(expandBtn);

      header.appendChild(left);
      header.appendChild(controls);

      const content = document.createElement('div');
      content.className = 'content';

      if (z.id === 'andy'){
        content.innerHTML = `
          <div class="panel">
            <input class="input" placeholder="Drop or paste (visual only)" />
            <input class="input" placeholder="Command" />
            <div class="button-row">
              <button class="btn" type="button">Ingest</button>
              <button class="btn secondary" type="button">Dry run</button>
            </div>
          </div>
        `;
      } else if (z.id === 'status'){
        const status = {
          constraints: { persistentAgent:false, liveRAG:false, backgroundProcess:false },
          memoryLayers: {
            windowLog: "DEFINED (not running)",
            notion: "DEFINED (not running)",
            archive: "DEFINED (not running)"
          },
          cockpit: { layer: "3.1", persistence: "OFF (by design)", goControl: "manual GO only" }
        };
        content.innerHTML = `<div class="statusBox">${JSON.stringify(status, null, 2)}</div>`;
      } else if (z.id === 'parent'){
        content.innerHTML = `
          <div style="display:flex;flex-direction:column;gap:10px;">
            <div style="color:var(--muted);font-size:.98rem;">
              Root authority surface. (UI lock active)
            </div>
          </div>
        `;
      } else {
        content.innerHTML = `<div style="height:86px"></div>`;
      }

      el.appendChild(header);
      el.appendChild(content);

      // Focus on click (buttons won't hijack focus)
      el.addEventListener('click', (e) => {
        if (e.target.closest('button')) return;
        setFocus(el);
      });

      // Collapse/Expand actions
      collapseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (z.locked) return;
        goHomeAndCollapse(el);
      });

      expandBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        el.classList.remove('collapsed');
        clearFocus(); // calm reset
      });

      // Drag (header only) — disabled for Parent
      if (!z.locked){
        enableDrag(el, header);
      }

      return el;
    }

    const zoneEls = ZONES.map(buildZone);
    zoneEls.forEach(el => stage.appendChild(el));

    function sizeStage(){
      const fr = document.getElementById('frame').getBoundingClientRect();
      stage.style.width = fr.width + 'px';
      stage.style.height = fr.height + 'px';
    }
    sizeStage();

    window.addEventListener('resize', () => {
      sizeStage();
      zoneEls.forEach(el => {
        const x = parseFloat(el.style.left || '0');
        const y = parseFloat(el.style.top  || '0');
        const c = clampToStage(x, y, el);
        el.style.left = c.x + 'px';
        el.style.top  = c.y + 'px';
      });
    });

    // Focus system (Parent NEVER blurred)
    function clearFocus(){
      zoneEls.forEach(z => z.classList.remove('focused','blurred'));
      veil.classList.remove('on');
    }

    function setFocus(target){
      const targetId = target.dataset.zone;
      zoneEls.forEach(z => {
        const locked = z.dataset.locked === '1';
        if (locked){
          z.classList.remove('blurred');      // parent stays sharp
          z.classList.remove('focused');      // parent doesn’t “jump forward”
          return;
        }
        z.classList.toggle('focused', z === target);
        z.classList.toggle('blurred', z !== target);
      });
      // Veil only indicates “focus mode”, but does not force go-home
      veil.classList.add('on');
    }

    // Clicking veil => clear focus (full cockpit back)
    veil.addEventListener('click', clearFocus);

    // Clicking empty stage area => clear focus (full cockpit back)
    stage.addEventListener('mousedown', (e) => {
      if (e.target.closest('.zone')) return;
      clearFocus();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') clearFocus();
    });

    // Drag system
    function enableDrag(el, handle){
      let dragging = false;
      let startX = 0, startY = 0;
      let origX  = 0, origY  = 0;
      let raf = 0;
      let pending = null;

      const onMove = (clientX, clientY) => {
        const dx = clientX - startX;
        const dy = clientY - startY;
        const nx = origX + dx;
        const ny = origY + dy;

        pending = { x: nx, y: ny };
        if (!raf){
          raf = requestAnimationFrame(() => {
            raf = 0;
            if (!pending) return;
            const c = clampToStage(pending.x, pending.y, el);
            el.style.left = c.x + 'px';
            el.style.top  = c.y + 'px';
          });
        }
      };

      handle.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        if (e.target.closest('button')) return;

        dragging = true;
        el.classList.add('dragging');
        setFocus(el);

        const rect = el.getBoundingClientRect();
        const srect = stage.getBoundingClientRect();
        origX = rect.left - srect.left;
        origY = rect.top  - srect.top;

        startX = e.clientX;
        startY = e.clientY;

        e.preventDefault();
      });

      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        onMove(e.clientX, e.clientY);
      });

      window.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        el.classList.remove('dragging');

        const x = snap(parseFloat(el.style.left || '0'));
        const y = snap(parseFloat(el.style.top  || '0'));
        const c = clampToStage(x, y, el);
        el.style.left = c.x + 'px';
        el.style.top  = c.y + 'px';
      });
    }

    // Collapse -> go-home (non-parent only)
    function goHomeAndCollapse(el){
      const hx = parseFloat(el.dataset.homeX || '0');
      const hy = parseFloat(el.dataset.homeY || '0');

      el.style.transition =
        `transform var(--dur) var(--ease),
         filter var(--dur) var(--ease),
         left var(--dur2) var(--ease),
         top var(--dur2) var(--ease)`;

      el.style.left = hx + 'px';
      el.style.top  = hy + 'px';

      window.setTimeout(() => {
        el.classList.add('collapsed');
        el.style.transition = '';
        clearFocus();
      }, 280);
    }

    // Initial calm
    clearFocus();
  </script>
</body>
</html>
